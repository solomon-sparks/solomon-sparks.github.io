<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Solo Journals</title>
    <link rel="stylesheet" href="css/style.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>
    <header>
      <div class="header-content">
        <div class="nav-container">
          <div class="nav-section nav-left">
            <!-- Left nav items -->
            <div class="nav-item">
              <a href="#journals">JOURNALS</a>
              <div class="dropdown-menu">...</div>
            </div>
            <div class="nav-item">
              <a href="#leather">LEATHER</a>
              <div class="dropdown-menu">...</div>
            </div>
            <div class="nav-item">
              <a href="#art">ART</a>
              <div class="dropdown-menu">...</div>
            </div>
          </div>

          <div class="logo-container">
            <a href="#top" class="logo">SOLO </a>
          </div>

          <div class="nav-section nav-right">
            <!-- Right nav items -->
            <div class="nav-item">
              <a href="#limited">LIMITED EDITION</a>
              <div class="dropdown-menu">...</div>
            </div>
            <div class="nav-item">
              <a href="about.html">ABOUT</a>
              <div class="dropdown-menu">...</div>
            </div>
            <div class="nav-item">
              <a href="#search">SEARCH</a>
              <div class="dropdown-menu">...</div>
            </div>
          </div>
        </div>
      </div>
    </header>

    <main class="slides" id="slides">
      <!-- Slide 1 -->
      <section class="slide bg-ink" id="home">
        <div class="content">
          <h1>SOLO</h1>
          <p>
            Refined craftsmanship. Elegant design. Designed to move with your
            mind.
          </p>
          <button class="cta-button">Shop Now</button>
        </div>
      </section>

      <!-- Slide 2 (placeholder – swap solid color for image/video later) -->
      <section class="slide bg-ivory" id="journals">
        <div class="content" style="color: #111">
          <h1>Journals</h1>
          <p>
            Premium refills and leather covers. Replace this solid color with
            your hero image or autoplay video later.
          </p>
          <button class="cta-button" style="background: #111; color: #fff">
            Explore
          </button>
        </div>
      </section>

      <!-- Slide 3 -->
      <section class="slide bg-olive" id="leather">
        <div class="content">
          <h1>Leather</h1>
          <p>Supple materials. Minimal hardware. Iconic silhouettes.</p>
          <button class="cta-button">Discover</button>
        </div>
      </section>

      <!-- Slide 4 -->
      <section class="slide bg-night" id="limited">
        <div class="content">
          <h1>Limited Editions</h1>
          <p>Rotating collaborations and seasonal colorways.</p>
          <button class="cta-button">View Drops</button>
        </div>
      </section>

      <!-- Slide 5: Legal / Footer as its own page -->
      <section class="slide bg-ivory" id="legal">
        <div class="content" style="color: #111">
          <p class="legal-note">© 2025 Solo Journals. All rights reserved.</p>
        </div>
      </section>
    </main>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const navItems = document.querySelectorAll(".nav-item");
        const dropdowns = document.querySelectorAll(".dropdown-menu");

        // Set up hover logic per nav item
        navItems.forEach((item) => {
          const dropdown = item.querySelector(".dropdown-menu");

          item.addEventListener("mouseenter", () => {
            closeAllDropdowns();
            if (dropdown) dropdown.classList.add("active");
          });

          item.addEventListener("mouseleave", (e) => {
            if (!item.contains(e.relatedTarget)) {
              if (dropdown) dropdown.classList.remove("active");
            }
          });

          if (dropdown) {
            dropdown.addEventListener("mouseleave", (e) => {
              if (!item.contains(e.relatedTarget)) {
                dropdown.classList.remove("active");
              }
            });
          }
        });

        // ✅ Core fix: close dropdown if cursor moves into whitespace or logo
        document
          .querySelector(".header-content")
          .addEventListener("mouseover", (e) => {
            const isInsideNavItem = e.target.closest(".nav-item");
            const isInsideDropdown = e.target.closest(".dropdown-menu");
            if (!isInsideNavItem && !isInsideDropdown) {
              closeAllDropdowns();
            }
          });

        function closeAllDropdowns() {
          dropdowns.forEach((el) => el.classList.remove("active"));
        }
      });
    </script>

    <script>
      // Overlay slide controller (wheel, touch, keyboard) with hard gesture gating
      (function () {
        const stage = document.getElementById("slides");
        if (!stage) return;
        const slides = Array.from(stage.querySelectorAll(".slide"));
        const DURATION = 720; // ms (should match CSS ~700ms)

        let idx = 0; // active slide index
        let lock = false; // true while animating
        let gate = true; // gesture gate: one slide per gesture

        function setPositions() {
          slides.forEach((s, i) => {
            s.classList.remove(
              "is-active",
              "is-above",
              "is-below",
              "entering",
              "from-below",
              "from-above",
              "to-center"
            );
            if (i < idx) s.classList.add("is-above");
            else if (i === idx) s.classList.add("is-active");
            else s.classList.add("is-below");
          });
        }

        function overlayEnter(nextIndex) {
          const current = slides[idx];
          const incoming = slides[nextIndex];
          const dir = nextIndex > idx ? "down" : "up";

          // Clear and lay out a baseline stack first
          slides.forEach((s, i) => {
            s.className = s.className
              .replace(
                /\b(is-active|is-above|is-below|entering|from-below|from-above|to-center|exiting|to-below)\b/g,
                ""
              )
              .trim();
          });

          if (dir === "down") {
            // DOWN: current stays static; incoming slides up over it
            slides.forEach((s, i) => {
              if (i < idx) s.classList.add("is-above");
              else if (i === idx) s.classList.add("is-active");
              else s.classList.add("is-below");
            });

            incoming.classList.add("entering", "from-below");
            void incoming.offsetHeight; // reflow
            incoming.classList.add("to-center");

            setTimeout(() => {
              idx = nextIndex;
              slides.forEach((s) =>
                s.classList.remove(
                  "entering",
                  "from-below",
                  "from-above",
                  "to-center",
                  "exiting",
                  "to-below"
                )
              );
              setPositions();
              lock = false;
              setTimeout(() => (gate = true), 120);
            }, DURATION);
            return;
          }

          // UP: reverse of DOWN
          // Target (incoming previous slide) stays static at center; current slides DOWN off-screen.
          const target = incoming; // previous slide (idx-1)

          // Make sure the target snaps into place without animating
          target.classList.add("no-transition");

          // 1) Lay out a clean stack: target centered, those above it positioned above, those below it positioned below
          slides.forEach((s, i) => {
            // clear any stacking classes first
            s.classList.remove("is-active", "is-above", "is-below");
            if (i < nextIndex) {
              s.classList.add("is-above");
            } else if (i === nextIndex) {
              s.classList.add("is-active"); // static, centered, no animation applied to target
            } else {
              s.classList.add("is-below");
            }
          });

          // Lock the target's non-animated position before moving current
          void target.offsetHeight;

          // 2) Promote current over target and animate it down to reveal the static target underneath
          // Make sure current starts at center visually
          current.classList.add("exiting"); // sits above with z-index and starts at translateY(0)
          // Force reflow to snapshot starting position (translateY(0))
          void current.offsetHeight;
          // Animate the current slide to below viewport
          current.classList.add("to-below");

          setTimeout(() => {
            idx = nextIndex; // commit new index
            // Cleanup transient animation classes
            slides.forEach((s) =>
              s.classList.remove(
                "entering",
                "from-below",
                "from-above",
                "to-center",
                "exiting",
                "to-below"
              )
            );
            // Remove the temporary no-transition class from target
            target.classList.remove("no-transition");
            // Recompute final stack based on new idx
            setPositions();
            lock = false;
            setTimeout(() => (gate = true), 120);
          }, DURATION);
          return;
        }

        function go(to) {
          if (lock || to === idx || to < 0 || to >= slides.length) return;
          lock = true; // block immediately
          gate = false; // close gesture gate immediately

          overlayEnter(to);
        }

        function onWheel(e) {
          e.preventDefault(); // stop native page scroll
          if (lock || !gate) return;
          const dy = e.deltaY || 0;
          if (Math.abs(dy) < 12) return; // ignore micro-nudges
          go(idx + (dy > 0 ? 1 : -1));
        }

        let startY = null;
        function onTouchStart(e) {
          if (lock || !gate) return;
          startY = e.touches[0].clientY;
        }
        function onTouchMove(e) {
          if (startY == null) return;
          if (lock || !gate) return;
          const dy = e.touches[0].clientY - startY;
          if (Math.abs(dy) > 50) {
            e.preventDefault();
            go(idx + (dy < 0 ? 1 : -1));
            startY = null; // end gesture immediately
          }
        }
        function onTouchEnd() {
          startY = null;
        }

        function onKey(e) {
          if (lock || !gate) return;
          if (e.key === "ArrowDown" || e.key === "PageDown") {
            e.preventDefault();
            go(idx + 1);
          } else if (e.key === "ArrowUp" || e.key === "PageUp") {
            e.preventDefault();
            go(idx - 1);
          } else if (e.key === "Home") {
            e.preventDefault();
            go(0);
          } else if (e.key === "End") {
            e.preventDefault();
            go(slides.length - 1);
          }
        }

        stage.addEventListener("wheel", onWheel, { passive: false });
        stage.addEventListener("touchstart", onTouchStart, { passive: true });
        stage.addEventListener("touchmove", onTouchMove, { passive: false });
        stage.addEventListener("touchend", onTouchEnd, { passive: true });
        window.addEventListener("keydown", onKey, { passive: false });

        // Init positions
        setPositions();
      })();
    </script>
  </body>
</html>
